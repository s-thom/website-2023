---
export interface Props {
  hasBigBoxExclusion?: boolean;
  shade?: boolean;
  imageUrl?: string;
}

const { hasBigBoxExclusion, shade, imageUrl } = Astro.props;
---

<div class="shader-backdrop" data-image-url={imageUrl} data-shade={shade}>
  <canvas class="shader-backdrop-canvas"></canvas>
  {hasBigBoxExclusion && <div class="shader-backdrop-box-size" />}
</div>

<style>
  .shader-backdrop,
  .shader-backdrop-canvas {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    height: 100%;
    width: 100%;
  }
  .shader-backdrop-box-size {
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    width: calc(100% - (var(--big-box-spacing) * 2));
    height: calc(100% - (var(--big-box-spacing-small) * 2));
  }
</style>

<script>
  import {
    createProgramInfo,
    resizeCanvasToDisplaySize,
    setBuffersAndAttributes,
    setUniforms,
    drawBufferInfo,
    createBufferInfoFromArrays,
    createTextures,
    type TextureOptions,
  } from "twgl.js";
  import vert from "../../lib/shaders/backdrop.vert";
  import frag from "../../lib/shaders/backdrop.frag";
  import type {
    SlidersOptionsMap,
    SlidersInitialisedEvent,
  } from "../../lib/shaders/sliders";

  const debugUniforms: SlidersOptionsMap = {
    uImageScale: {
      type: "float",
      value: 1,
      min: 0.01,
      max: 2,
      step: 0.01,
    },
    uBalatroTimeScale: {
      type: "float",
      value: 0.35,
      min: 0,
      max: 5,
      step: 0.01,
    },
    uBalatroPaintFactor: {
      type: "float",
      value: 0.33,
      min: 0,
      max: 1,
      step: 0.001,
    },
    uBalatroPaintIterations: {
      type: "int",
      value: 4,
      min: 0,
      max: 10,
    },
    uForceColorMode: {
      type: "boolean",
      value: false,
    },
    uColor1: {
      type: "rgba",
      value: [1, 0, 0, 1],
    },
    uColor2: {
      type: "rgba",
      value: [0, 1, 0, 1],
    },
    uColor3: {
      type: "rgba",
      value: [0, 0, 1, 1],
    },
    uColorMix1: {
      type: "float",
      value: 1,
      min: 0,
      max: 1,
      step: 0.001,
    },
    uColorMix2: {
      type: "float",
      value: 5,
      min: 0,
      max: 10,
      step: 0.001,
    },
  };

  window.addEventListener(
    "slidersinitialised",
    (event: InstanceType<typeof SlidersInitialisedEvent>) => {
      event.detail.registerSliders("backdrop", debugUniforms);
    },
  );

  document
    .querySelectorAll<HTMLDivElement>(".shader-backdrop")
    .forEach((backdropArea) => {
      const canvas = backdropArea.querySelector<HTMLCanvasElement>(
        "canvas.shader-backdrop-canvas",
      );
      if (!canvas) {
        return;
      }
      const bigBoxExclusionZone = backdropArea.querySelector<HTMLDivElement>(
        "div.shader-backdrop-box-size",
      );

      const gl = canvas.getContext("webgl2", { premultipliedAlpha: false });
      if (!gl) {
        canvas.classList.add("fully-hidden");
        return;
      }

      const programInfo = createProgramInfo(gl, [vert, frag]);

      const arrays = {
        // Cover the entire canvas with a single quad
        aPosition: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
      };
      const bufferInfo = createBufferInfoFromArrays(gl, arrays);

      const texturesSrc: { [key: string]: TextureOptions } = {
        // Default to 1x1 white square
        backdrop: {
          mag: gl.NEAREST,
          min: gl.LINEAR,
          src: [255, 255, 255, 0],
        },
      };
      const backdropImageUrl = backdropArea.dataset.imageUrl ?? undefined;
      const hasBackgroundImage = !!backdropImageUrl;
      if (hasBackgroundImage) {
        texturesSrc.backdrop = { src: backdropImageUrl };
      } else {
        // Add more iterations to paint effect
        debugUniforms.uBalatroPaintIterations.value = 9;
      }

      // Set ready when there's no background image
      let isReady = !hasBackgroundImage;
      const textures = createTextures(gl, texturesSrc, (err) => {
        if (err) {
          console.error(
            "Error loading textures for backdrop shader, falling back to untextured mode.",
            err,
          );
          return;
        }

        isReady = true;
      });

      const render = (time: DOMHighResTimeStamp) => {
        resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const uniforms: { [key: string]: any } = {
          uReady: isReady,
          uTime: time * 0.001,
          uResolution: [gl.canvas.width, gl.canvas.height],
          uUseBackdropImage: hasBackgroundImage,
          uTextureBackdrop: textures.backdrop,
        };
        for (const [key, value] of Object.entries(debugUniforms)) {
          uniforms[key] = value.value;
        }

        gl.useProgram(programInfo.program);
        setBuffersAndAttributes(gl, programInfo, bufferInfo);
        setUniforms(programInfo, uniforms);
        drawBufferInfo(gl, bufferInfo);

        requestAnimationFrame(render);
      };
      requestAnimationFrame(render);
    });
</script>
