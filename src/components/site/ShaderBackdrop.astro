---
export interface Props {
  hasBigBoxExclusion?: boolean;
  shade?: boolean;
  imageUrl?: string;
}

const { hasBigBoxExclusion, shade, imageUrl } = Astro.props;
---

<div class="shader-backdrop" data-image-url={imageUrl} data-shade={shade}>
  <canvas class="shader-backdrop-canvas"></canvas>
  {hasBigBoxExclusion && <div class="shader-backdrop-box-size" />}
</div>

<style>
  .shader-backdrop,
  .shader-backdrop-canvas {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    height: 100%;
    width: 100%;
  }
  .shader-backdrop-box-size {
    pointer-events: none;
    opacity: 0;
    visibility: hidden;
    width: calc(100% - (var(--big-box-spacing) * 2));
    height: calc(100% - (var(--big-box-spacing-small) * 2));
  }
</style>

<script>
  import {
    createProgramInfo,
    resizeCanvasToDisplaySize,
    setBuffersAndAttributes,
    setUniforms,
    drawBufferInfo,
    createBufferInfoFromArrays,
    createTextures,
    type TextureOptions,
  } from "twgl.js";
  import vert from "../../lib/shaders/backdrop.vert";
  import frag from "../../lib/shaders/backdrop.frag";
  import type {
    SlidersOptionsMap,
    SlidersInitialisedEvent,
  } from "../../lib/shaders/sliders";

  const debugUniforms: SlidersOptionsMap = {
    uHasCutout: {
      type: "boolean",
      value: true,
    },
    uImageScale: {
      type: "float",
      min: 0.01,
      max: 2,
      value: 1.1,
      step: 0.01,
    },
  };

  window.addEventListener(
    "slidersinitialised",
    (event: InstanceType<typeof SlidersInitialisedEvent>) => {
      event.detail.registerSliders("backdrop", debugUniforms);
    },
  );

  document
    .querySelectorAll<HTMLDivElement>(".shader-backdrop")
    .forEach((backdropArea) => {
      const canvas = backdropArea.querySelector<HTMLCanvasElement>(
        "canvas.shader-backdrop-canvas",
      );
      if (!canvas) {
        return;
      }
      const bigBoxExclusionZone = backdropArea.querySelector<HTMLDivElement>(
        "div.shader-backdrop-box-size",
      );

      const gl = canvas.getContext("webgl2", { premultipliedAlpha: false });
      if (!gl) {
        canvas.classList.add("fully-hidden");
        return;
      }

      const programInfo = createProgramInfo(gl, [vert, frag]);

      const arrays = {
        // Cover the entire canvas with a single quad
        aPosition: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],
      };
      const bufferInfo = createBufferInfoFromArrays(gl, arrays);

      const texturesSrc: { [key: string]: TextureOptions } = {
        // Default to 1x1 white square
        backdrop: {
          mag: gl.NEAREST,
          min: gl.LINEAR,
          src: [255, 255, 255, 0],
        },
      };
      const backdropImageUrl = backdropArea.dataset.imageUrl ?? undefined;
      const hasShade = "shade" in backdropArea.dataset;
      if (backdropImageUrl) {
        texturesSrc.remote = { src: backdropImageUrl };
      }

      let texturesLoaded = false;
      const textures = createTextures(gl, texturesSrc, (err) => {
        if (err) {
          console.error(
            "Error loading textures for backdrop shader, falling back to untextured mode.",
            err,
          );
          return;
        }

        texturesLoaded = true;

        if (textures.remote) {
          // Overwrite default with loaded image
          textures.backdrop = textures.remote;
        }
      });

      const render = (time: DOMHighResTimeStamp) => {
        resizeCanvasToDisplaySize(gl.canvas as HTMLCanvasElement);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

        const contentRect = bigBoxExclusionZone
          ? bigBoxExclusionZone.getBoundingClientRect()
          : { width: 0, height: 0 };

        const uniforms: { [key: string]: any } = {
          uTime: time * 0.001,
          uResolution: [gl.canvas.width, gl.canvas.height],
          uContentRect: [contentRect.width, contentRect.height],
          uHasShade: hasShade,
          uTexturesLoaded: texturesLoaded,
          uTextureBackdrop: textures.backdrop,
        };
        for (const [key, value] of Object.entries(debugUniforms)) {
          uniforms[key] = value.value;
        }

        gl.useProgram(programInfo.program);
        setBuffersAndAttributes(gl, programInfo, bufferInfo);
        setUniforms(programInfo, uniforms);
        drawBufferInfo(gl, bufferInfo);

        requestAnimationFrame(render);
      };
      requestAnimationFrame(render);
    });
</script>
