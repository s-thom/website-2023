---
export interface Props {
  id: string;
  shade?: boolean;
  imageUrl?: string;
}

const { id, shade, imageUrl } = Astro.props;
---

<div
  class="shader-backdrop"
  id={`backdrop-${id}`}
  data-image-url={imageUrl}
  data-shade={shade}
>
  <canvas class="shader-backdrop-canvas"></canvas>
</div>

<style>
  .shader-backdrop,
  .shader-backdrop-canvas {
    position: absolute;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
    height: 100%;
    width: 100%;
  }
</style>

<script>
  import { getOptionValue, subscribeToOption } from "../../lib/options";
  import fragment from "../../lib/shaders/backdrop.frag";
  import vertex from "../../lib/shaders/backdrop.vert";
  import { Interpolate, easeInOutCubic } from "../../lib/shaders/interpolate";
  import { setupShader } from "../../lib/shaders/setup";
  import type {
    SlidersInitialisedEvent,
    SlidersOptionsMap,
  } from "../../lib/shaders/sliders";
  import { range } from "../../util";

  const MIN_PAINT_FACTOR = 0.15;
  const MAX_PAINT_FACTOR = 0.45;

  document
    .querySelectorAll<HTMLDivElement>(".shader-backdrop")
    .forEach((backdropArea) => {
      const canvas = backdropArea.querySelector<HTMLCanvasElement>(
        "canvas.shader-backdrop-canvas",
      );

      if (!canvas) {
        return;
      }

      const editableUniforms: SlidersOptionsMap = {};
      window.addEventListener(
        "slidersinitialised",
        (event: InstanceType<typeof SlidersInitialisedEvent>) => {
          event.detail.registerSliders(backdropArea.id, editableUniforms);
        },
      );

      const uniforms: Record<string, unknown> = {};

      const backgroundUrl = backdropArea.dataset.imageUrl;
      const hasBackground = backgroundUrl !== undefined;

      uniforms.uUseBackdropImage = hasBackground;
      uniforms.uBalatroPaintIterations = hasBackground ? 4 : 9;

      let prefersReducedMotion = getOptionValue("motion") === "reduced";
      const interpolator = new Interpolate(
        easeInOutCubic,
        hasBackground || prefersReducedMotion ? 0 : 1,
      );
      subscribeToOption("motion", (value) => {
        prefersReducedMotion = value === "reduced";
        interpolator.setTarget(prefersReducedMotion ? 0 : 1, 1000);
      });

      // Intersection observer for changing multiplier during scroll
      let canvasIntersectionRatio = 1;
      const observer = new IntersectionObserver(
        (entries) => {
          for (const entry of entries) {
            if (entry.target === canvas) {
              canvasIntersectionRatio = entry.intersectionRatio;
            }
          }
        },
        {
          // Fire callback on many changes. 100 should be smooth enough.
          threshold: range(101).map((n) => n / 100),
        },
      );
      observer.observe(canvas);

      const { start } = setupShader({
        canvas,
        shaders: { vertex, fragment },
        uniforms,
        onFrame: (time) => {
          uniforms.uBalatroPaintFactor =
            ((1 - canvasIntersectionRatio) *
              (MAX_PAINT_FACTOR - MIN_PAINT_FACTOR) +
              MIN_PAINT_FACTOR) *
            interpolator.getValue();
        },
        textures: hasBackground ? [{ src: backgroundUrl }] : undefined,
        onTexturesReady: () => {
          interpolator.setTarget(prefersReducedMotion ? 0 : 1, 10_000);
          start();
        },
      });

      if (!hasBackground) {
        start();
      }
    });
</script>
